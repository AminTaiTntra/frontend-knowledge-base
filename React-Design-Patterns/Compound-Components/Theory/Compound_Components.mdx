# Compound Components Pattern in React

## Overview

The **Compound Components** pattern is a powerful design pattern in React that allows you to create a set of components that work together as a cohesive unit. This pattern promotes better separation of concerns, improved flexibility, and more intuitive component composition.

In this guide, we'll explore what compound components are, why they're useful, and how they differ from anti-patterns. We'll use a practical example: building a **PostCard component** in two ways - the anti-pattern and the recommended approach.

---

## The Problem: Anti-Pattern Approach

### What's Wrong With The Anti-Pattern?

The anti-pattern approach bundles all logic and UI into a single, monolithic component. Let's look at the `AntiPostCard` component:

```tsx
// ❌ Anti-Pattern: All logic bundled in one component
type AntiPostCardProps = {
  id: number
  title: string
  content: string
  user: {
    id: number
    name: string
  },
  isOnProfilePage?: boolean
};

export default function AntiPostCard({ post }: Props) {
  return (
    <div className="w-full bg-white rounded-lg shadow-md ...">
      <div className="bg-gray-200 h-32 flex items-center justify-center">
        <span className="text-black font-bold">{post.id}</span>
      </div>

      <div className="p-6">
        <h2 className="text-2xl font-bold text-black mb-2">{post.title}</h2>
        <p className="text-gray-700 text-sm mb-4">{post.content}</p>
        
        {/* Conditional rendering based on props */}
        {!post.isOnProfilePage && (
          <p className="text-xs text-gray-600 font-medium mb-6">
            By <span className="font-semibold text-black">{post.user.name}</span>
          </p>
        )}

        <div className="flex gap-3">
          <button className="flex-1 bg-black text-gray-700 ...">
            Read More
          </button>
          <button className="flex-1 border-2 border-black ...">
            Like
          </button>
        </div>
      </div>
    </div>
  )
}
```

### Issues With This Approach:

1. **Inflexible**: All sections are tightly coupled. You can't easily rearrange or skip parts.
2. **Conditional Hell**: Using props like `isOnProfilePage` leads to complex conditional logic.
3. **Poor Separation of Concerns**: Layout, styling, and logic are mixed together.
4. **Hard to Extend**: Adding new features requires modifying the entire component.
5. **Limited Reusability**: Sub-components can't be used independently.

### Usage:

```tsx
<AntiPostCard
  post={{
    isOnProfilePage: true,
    id: 1,
    title: "Anti Design Pattern",
    content: "This is the anti-pattern approach...",
    user: { id: 1, name: "Amin Tai" }
  }}
/>
```

---

## The Solution: Compound Components Pattern

### What Are Compound Components?

Compound components are a set of components that share state and work together to form a complete UI. Instead of having all logic in one component, you break it down into smaller, focused sub-components that communicate via **Context API**.

### Architecture Overview

```
PostCardComponent (Parent)
├── Context Provider
├── PostCardComponent.Id (Sub-component)
├── PostCardComponent.Title (Sub-component)
├── PostCardComponent.Content (Sub-component)
├── PostCardComponent.Author (Sub-component)
└── PostCardComponent.Actions (Sub-component)
```

### Implementation

#### 1. Context Setup

```tsx
// componets/PostCardComponent.tsx
import React from "react";
import usePostCardContext from "../hooks/usePostCardContext";

type PostCardContextType = {
    post: PostCardProps;
};

type PostCardProps = {
    id: number
    title: string
    content: string
    user: {
        id: number
        name: string
    },
    isOnProfilePage?: boolean
};

type Props = {
    post: PostCardProps;
    children: React.ReactNode;
};

// ✅ Create Context
export const PostCardContext = React.createContext<PostCardContextType | undefined>(undefined);
```

#### 2. Parent Component

```tsx
export default function PostCardComponent({ children, post }: Props) {
    return (
        <PostCardContext.Provider value={{ post }}>
            <div className="w-full bg-white rounded-lg shadow-md hover:shadow-lg transition-shadow duration-300 overflow-hidden border border-gray-300">
                {children}
            </div>
        </PostCardContext.Provider>
    )
}
```

#### 3. Sub-Components (Compound Components)

```tsx
// ID Section
PostCardComponent.Id = function PostCardId() {
    const {post} = usePostCardContext();

    return (
        <div className="bg-gray-200 h-32 flex items-center justify-center">
            <span className="text-black font-bold text-center block">{post.id}</span>
        </div>
    );
}

// Title Section
PostCardComponent.Title = function PostCardTitle() {
    const {post} = usePostCardContext();
    return <h2 className="text-2xl font-bold text-black mb-2">{post.title}</h2>;
}

// Content Section
PostCardComponent.Content = function PostCardContent() {
    const {post} = usePostCardContext();
    return <p className="text-gray-700 text-sm mb-4 leading-relaxed">{post.content}</p>;
}

// Author Section
PostCardComponent.Author = function PostCardAuthor() {
    const {post} = usePostCardContext();
    
    if (post.isOnProfilePage) return null;

    return (
        <p className="text-xs text-gray-600 font-medium mb-6">
            By <span className="font-semibold text-black">{post.user.name}</span>
        </p>
    );
}

// Actions Section
PostCardComponent.Actions = function PostCardActions() {
    return (
        <div className="flex gap-3">
            <button className="flex-1 bg-black text-gray-700 px-4 py-2 rounded-md font-medium hover:bg-gray-800 transition-colors duration-200">
                Read More
            </button>
            <button className="flex-1 border-2 border-black text-black px-4 py-2 rounded-md font-medium hover:bg-gray-100 transition-colors duration-200">
                Like
            </button>
        </div>
    )
}
```

#### 4. Custom Hook for Context

```tsx
// hooks/usePostCardContext.ts
import React from "react";
import { PostCardContext } from "../componets/PostCardComponent";

const usePostCardContext = () => {
    const context = React.useContext(PostCardContext);
    if (!context) {
        throw new Error("PostCardComponent sub-components must be used within a PostCardComponent");
    }
    return context;
};

export default usePostCardContext;
```

### Usage

```tsx
// ✅ Compound Components Pattern: Flexible and Composable
<PostCardComponent
  post={{
    isOnProfilePage: false,
    id: 2,
    title: "Compound Components Pattern",
    content: "The recommended approach using compound components...",
    user: { id: 2, name: "Amin Tai" }
  }}
>
  <PostCardComponent.Id />
  <div className='p-6'>
    <PostCardComponent.Title />
    <PostCardComponent.Content />
    <PostCardComponent.Author />
    <PostCardComponent.Actions />
  </div>
</PostCardComponent>
```

---

## Key Differences

| Aspect | Anti-Pattern | Compound Components |
|--------|--------------|-------------------|
| **Structure** | Monolithic component | Multiple sub-components |
| **Flexibility** | Limited | Highly flexible |
| **Composition** | Fixed layout | Custom arrangement |
| **State Management** | Prop drilling | Context API |
| **Conditional Logic** | Props-based | Component-based |
| **Reusability** | Low | High |
| **Maintainability** | Hard | Easy |

---

## Advantages of Compound Components

### 1. **Flexibility**
You can arrange sub-components in any order or skip them entirely:

```tsx
// Rearrange sections
<PostCardComponent post={post}>
  <PostCardComponent.Actions />
  <div className='p-6'>
    <PostCardComponent.Title />
    <PostCardComponent.Content />
  </div>
  <PostCardComponent.Id />
</PostCardComponent>

// Skip the author section entirely
<PostCardComponent post={post}>
  <PostCardComponent.Id />
  <div className='p-6'>
    <PostCardComponent.Title />
    <PostCardComponent.Content />
    <PostCardComponent.Actions />
  </div>
</PostCardComponent>
```

### 2. **Separation of Concerns**
Each sub-component handles one specific responsibility:
- `Id`: Displays the post ID
- `Title`: Displays the title
- `Content`: Displays the content
- `Author`: Displays author info (with conditional logic)
- `Actions`: Displays buttons

### 3. **Better Composition**
No prop drilling, no conditional logic in the parent. The consumer decides what to render.

### 4. **Easier Testing**
Each sub-component can be tested independently.

### 5. **Improved DX (Developer Experience)**
The API is self-documenting and intuitive:

```tsx
// It's obvious what components are available
<PostCardComponent>
  <PostCardComponent.Title />
  <PostCardComponent.Content />
  {/* IDE autocomplete shows all available sub-components */}
</PostCardComponent>
```

---

## When to Use Compound Components

### ✅ Use When:
- You have a complex component with multiple parts
- Different parts need to be arranged/composed differently
- You want to provide flexibility without prop drilling
- Building UI component libraries
- Creating form components (similar to `<select>` and `<option>`)

### ❌ Avoid When:
- Simple components with few variations
- No need for flexible composition
- Performance is critical (Context can cause unnecessary re-renders)

---

## Real-World Examples

The compound components pattern is used extensively in popular libraries:

- **HTML native elements**: `<select>` + `<option>`, `<table>` + `<tr>` + `<td>`
- **Headless UI**: Radio Group, Listbox, Menu
- **Reach UI**: Tabs, Accordion
- **Custom Design Systems**: Complex form components, data tables

---

## Conclusion

The **Compound Components** pattern is a powerful tool for creating flexible, maintainable, and composable React components. While it requires more boilerplate than simple components, the benefits in terms of flexibility and maintainability make it worth the effort for complex component compositions.

By understanding the differences between the anti-pattern and the compound components approach, you can make better architectural decisions when building React applications.

### Quick Recap:

- **Anti-Pattern**: Everything in one component = Inflexible and hard to maintain
- **Compound Components**: Flexible sub-components sharing context = Better composition and maintenance
- **Key Tool**: React Context API for sharing state between sub-components
- **Best For**: Complex components with multiple parts that need flexible composition
